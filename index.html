<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modern Othello — Very Strong AI</title>
<meta name="description" content="Othello with a much stronger AI: iterative deepening, persistent transposition table, endgame exact solver, improved move ordering, time-aware search." />
<style>
  :root{--bg:#0b1220;--card:#0f1724;--muted:#9aa4bf;--accent:#60a5fa;--accent-2:#34d399;--glass:rgba(255,255,255,0.03);--glass-border:rgba(255,255,255,0.06);color-scheme:dark}
  [data-theme='light']{--bg:#f7fafc;--card:#fff;--muted:#475569;--accent:#0369a1;--accent-2:#059669;--glass:rgba(0,0,0,0.03);--glass-border:rgba(0,0,0,0.06);color-scheme:light}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;background:linear-gradient(180deg,var(--bg),#071026);color:#e6eef8}
  .wrap{max-width:1100px;margin:28px auto;padding:20px;display:grid;grid-template-columns:1fr 360px;gap:18px}
  @media(max-width:980px){.wrap{grid-template-columns:1fr;padding:14px}}
  .panel{background:linear-gradient(180deg,var(--card),rgba(0,0,0,0.04));border-radius:12px;padding:16px;border:1px solid var(--glass-border)}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  header h1{font-size:20px;margin:0}
  .meta{color:var(--muted);font-size:13px}
  .board-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
  .board{width:min(520px,92vw);aspect-ratio:1;display:grid;grid-template-columns:repeat(8,1fr);gap:6px;padding:6px;background:linear-gradient(180deg,#061226,#081a2b);border-radius:12px}
  .cell{background:linear-gradient(180deg,#0a2d14,#053214);border-radius:6px;position:relative;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform .12s ease}
  .cell:hover{transform:translateY(-3px)}
  .cell.disabled{opacity:.55;cursor:default;transform:none}
  .disc{width:78%;height:78%;border-radius:50%;box-shadow:0 6px 14px rgba(2,6,23,0.6) inset}
  .disc.black{background:linear-gradient(180deg,#000,#222)}
  .disc.white{background:linear-gradient(180deg,#fff,#e6e6e6)}
  .hint-dot{position:absolute;width:12%;height:12%;border-radius:50%;background:rgba(255,255,255,0.22)}
  .controls{display:flex;flex-direction:column;gap:12px}
  .row{display:flex;gap:8px;align-items:center}
  button{background:transparent;border:1px solid var(--glass-border);padding:8px 12px;border-radius:10px;color:inherit;cursor:pointer}
  .btn-primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#022}
  .status{font-weight:600}
  .score{display:flex;gap:8px;align-items:center}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px;border-radius:999px;background:linear-gradient(90deg,rgba(255,255,255,0.02),transparent);border:1px solid var(--glass-border)}
  .small{font-size:13px;color:var(--muted)}
  .difficulty{width:100%}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .moves{max-height:200px;overflow:auto;padding-right:6px}
  .move{padding:6px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid var(--glass-border)}
  .top-actions{display:flex;gap:8px;align-items:center}
  .toggle{display:flex;gap:8px;align-items:center}
  .themeBtn{padding:6px 10px;border-radius:8px}
  footer.pagefoot{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}
</style>
</head>
<body data-theme="dark">
  <main class="wrap">
    <section class="panel" aria-label="Game panel">
      <header>
        <div>
          <h1>Modern Othello — Very Strong AI</h1>
          <div class="meta">Now with endgame solver and persistent TT — much stronger.</div>
        </div>
        <div class="top-actions">
          <div class="chip score" title="Score"><span id="blackScore">2</span> ⚫ — ⚪ <span id="whiteScore">2</span></div>
          <div class="chip status" id="turnIndicator">Black's turn</div>
        </div>
      </header>

      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="Othello board"></div>
        <div class="row small">
          <div>Click a cell to place. Hints show legal moves. U=undo, R=restart.</div>
        </div>
      </div>

    </section>

    <aside class="panel controls" aria-label="Controls">
      <div class="row">
        <button id="newBtn" class="btn-primary">New Game</button>
        <button id="undoBtn">Undo</button>
        <button id="hintBtn">Toggle Hints</button>
      </div>

      <div>
        <label class="small">Play as:</label>
        <div class="row" style="margin-top:6px">
          <label><input type="radio" name="side" value="black" checked /> Black (goes first)</label>
          <label style="margin-left:8px"><input type="radio" name="side" value="white" /> White</label>
        </div>
      </div>

      <div>
        <label class="small">Difficulty (AI time per move)</label>
        <input id="diff" class="difficulty" type="range" min="1" max="5" value="5" />
        <div class="row small"><div>Quick</div><div style="margin-left:auto">Deep</div></div>
      </div>

      <div>
        <label class="small">AI Info</label>
        <div class="row"><div id="depthLabel">—</div><div class="small" style="margin-left:auto" id="timeEst">—</div></div>
      </div>

      <div>
        <label class="small">Move history</label>
        <div class="moves" id="moves"></div>
      </div>

      <div class="footer">
        <div class="legend small">Improvements: persistent TT, endgame exact search, history heuristic, stronger eval.</div>
        <div style="margin-top:8px" class="small">If it's still beatable often, we'll add WebWorker parallel search & deeper endgame solver.</div>
        <div style="margin-top:12px" class="row">
          <button id="themeBtn" class="themeBtn">Toggle Theme</button>
          <a id="exportBtn" href="#" style="margin-left:auto">Export game</a>
        </div>
      </div>
    </aside>

    <footer class="pagefoot">Built with plain HTML/CSS/JavaScript — enjoy!</footer>
  </main>

<script>
// Very Strong Othello AI
const SIZE = 8;
const DIRS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

// DOM
const boardEl = document.getElementById('board');
const blackScoreEl = document.getElementById('blackScore');
const whiteScoreEl = document.getElementById('whiteScore');
const turnIndicator = document.getElementById('turnIndicator');
const newBtn = document.getElementById('newBtn');
const undoBtn = document.getElementById('undoBtn');
const hintBtn = document.getElementById('hintBtn');
const diffRange = document.getElementById('diff');
const depthLabel = document.getElementById('depthLabel');
const movesEl = document.getElementById('moves');
const hintToggle = {on:true};
const themeBtn = document.getElementById('themeBtn');
const exportBtn = document.getElementById('exportBtn');

let board = null; let turn = 1; let playerSide = 1; let history = []; let moveHistory = []; let hintCells = []; let aiThinking = false;

// --- persistent transposition table and Zobrist ---
const zobrist = (function(){
  const table = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>[randomBig(), randomBig()]));
  function randomBig(){ // make 64-bit BigInt
    const hi = BigInt(Math.floor(Math.random()*0x100000000));
    const lo = BigInt(Math.floor(Math.random()*0x100000000));
    return ((hi<<32n) | lo) & ((1n<<64n)-1n);
  }
  return {table};
})();
const transpo = new Map(); // persistent across moves
const historyHeuristic = new Map(); // key: move idx -> score

function computeZobrist(b){ let h=0n; for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ if(b[r][c]===1) h ^= zobrist.table[r][c][0]; else if(b[r][c]===-1) h ^= zobrist.table[r][c][1]; } return h.toString(); }

// --- board helpers ---
function makeEmptyBoard(){ return Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>0)); }
function copyBoard(b){ return b.map(r=>r.slice()); }
function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

function legalMoves(b, side){ const moves = new Map();
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ if(b[r][c]!==0) continue; let totalFlips=[]; for(const [dr,dc] of DIRS){ let rr=r+dr, cc=c+dc, flips=[]; while(inBounds(rr,cc) && b[rr][cc]===-side){ flips.push([rr,cc]); rr+=dr; cc+=dc; } if(flips.length>0 && inBounds(rr,cc) && b[rr][cc]===side) totalFlips=totalFlips.concat(flips); } if(totalFlips.length>0) moves.set(r*SIZE+c, totalFlips); }
  return moves; }

function applyMove(b, side, idx, flips){ const nb = copyBoard(b); const r=Math.floor(idx/SIZE), c=idx%SIZE; nb[r][c]=side; for(const [fr,fc] of flips) nb[fr][fc]=side; return nb; }
function countPieces(b){ let bC=0,wC=0; for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ if(b[r][c]===1) bC++; if(b[r][c]===-1) wC++; } return [bC,wC]; }
function countEmpty(b){ let e=0; for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++) if(b[r][c]===0) e++; return e; }

// --- evaluation (enhanced) ---
const WEIGHTS = [
  [120,-20,20,5,5,20,-20,120],
  [-20,-40,-5,-5,-5,-5,-40,-20],
  [20,-5,15,3,3,15,-5,20],
  [5,-5,3,3,3,3,-5,5],
  [5,-5,3,3,3,3,-5,5],
  [20,-5,15,3,3,15,-5,20],
  [-20,-40,-5,-5,-5,-5,-40,-20],
  [120,-20,20,5,5,20,-20,120]
];

function evaluate(b, side){ const [bC,wC] = countPieces(b); const my = side===1? bC : wC; const opp = side===1? wC : bC; let score = (my - opp) * 10;
  // positional
  let pos=0; for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ if(b[r][c]===side) pos += WEIGHTS[r][c]; else if(b[r][c]===-side) pos -= WEIGHTS[r][c]; }
  score += pos;
  // mobility
  const myMoves = legalMoves(b, side).size; const oppMoves = legalMoves(b, -side).size; if(myMoves+oppMoves>0) score += ((myMoves - oppMoves) * 18);
  // corner
  const corners = [[0,0],[0,7],[7,0],[7,7]]; for(const [r,c] of corners){ if(b[r][c]===side) score += 250; else if(b[r][c]===-side) score -= 250; }
  // frontier
  let myFront=0, oppFront=0; for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ if(b[r][c]!==0){ for(const [dr,dc] of DIRS){ const rr=r+dr, cc=c+dc; if(inBounds(rr,cc) && b[rr][cc]===0){ if(b[r][c]===side) myFront++; else oppFront++; break; } } } }
  score += (oppFront - myFront) * 10;
  return score;
}

// --- ordering & heuristics ---
function movePriority(k){ const r=Math.floor(k/SIZE), c=k%SIZE; if((r===0||r===7)&&(c===0||c===7)) return 0; if((r===0||r===7)&&(c===1||c===6)) return 200; if((r===1||r===6)&&(c===0||c===7)) return 200; if(r===0||r===7||c===0||c===7) return 10; return 50; }

// --- negamax with alpha-beta, time checks, TT, history heuristic ---
function negamax(b, side, depth, alpha, beta, ctx){
  const zob = computeZobrist(b);
  const tt = transpo.get(zob);
  if(tt && tt.depth >= depth){ if(tt.flag==='EXACT') return tt.score; if(tt.flag==='LOWER') alpha = Math.max(alpha, tt.score); else if(tt.flag==='UPPER') beta = Math.min(beta, tt.score); if(alpha >= beta) return tt.score; }

  const moves = legalMoves(b, side);
  if(depth===0 || moves.size===0){ return evaluate(b, side); }

  let value = -Infinity;
  // build ordered move list with history heuristic
  const ordered = Array.from(moves.keys()).map(k=>parseInt(k)).map(k=>({k,prio:movePriority(k),hist:historyHeuristic.get(k)||0})).sort((a,b)=> (a.prio - b.prio) || (b.hist - a.hist)).map(x=>x.k);

  for(const k of ordered){
    // time cutoff
    if(ctx && (performance.now() - ctx.start) > ctx.timeLimit) { ctx.timeout = true; break; }
    const child = applyMove(b, side, k, moves.get(k));
    let score = -negamax(child, -side, depth-1, -beta, -alpha, ctx);
    if(score > value) value = score;
    if(value > alpha) alpha = value;
    if(alpha >= beta){ // beta cutoff -> update history heuristic
      const prev = historyHeuristic.get(k) || 0; historyHeuristic.set(k, prev + (1<<depth)); break; }
  }
  // store
  let flag='EXACT'; if(value <= alpha) flag='UPPER'; else if(value >= beta) flag='LOWER'; transpo.set(computeZobrist(b), {depth, score: value, flag});
  return value;
}

// exact endgame search to terminal when few empties remain
function exactEndgameSearch(b, side){ // return best move by full-depth search to terminal
  const empties = countEmpty(b);
  if(empties === 0) return null;
  // do full search to terminal via negamax with depth = empties (but careful)
  const moves = legalMoves(b, side); if(moves.size===0) return null;
  let best = null; let bestScore = -Infinity;
  for(const k of Array.from(moves.keys()).map(x=>parseInt(x))){
    const child = applyMove(b, side, k, moves.get(k));
    const score = -negamax(child, -side, empties-1, -1e9, 1e9, {start:performance.now(), timeLimit:60000});
    if(score > bestScore){ bestScore = score; best = k; }
  }
  return best;
}

// iterative deepening controller with time limit; persistent transpo used
function findBestMove(rootBoard, side, maxTime){
  const start = performance.now(); const ctx = {start, timeLimit: maxTime, timeout:false};
  const empties = countEmpty(rootBoard);
  // if very few empties left, perform exact endgame search (strong)
  if(empties <= 14){ const exact = exactEndgameSearch(rootBoard, side); if(exact!=null) return {move:exact, depth:empties}; }

  let bestMove=null; let bestScore=-Infinity; let depth=1;
  while(true){
    const moves = legalMoves(rootBoard, side);
    if(moves.size===0) break;
    // ordered candidate list by quick eval
    const candidates = Array.from(moves.keys()).map(k=>parseInt(k)).map(k=>({k,score:evaluate(applyMove(rootBoard,side,k,moves.get(k)),side)})).sort((a,b)=>b.score-a.score).map(x=>x.k);
    let localBest=null; let localBestScore=-Infinity;
    for(const k of candidates){
      if(performance.now() - start > maxTime) { ctx.timeout=true; break; }
      try{
        const child = applyMove(rootBoard, side, k, moves.get(k));
        const val = -negamax(child, -side, depth-1, -1e9, 1e9, ctx);
        if(ctx.timeout) break;
        if(val > localBestScore){ localBestScore = val; localBest = k; }
      }catch(e){ console.error(e); }
    }
    if(localBest!=null){ bestMove = localBest; bestScore = localBestScore; }
    if(ctx.timeout) break;
    depth++;
    if(depth>30) break; // safety cap
  }
  return {move:bestMove, score:bestScore, depth:Math.max(1,depth-1)};
}

// --- UI and flow ---
function initGame(){ board = makeEmptyBoard(); board[3][3]=-1; board[4][4]=-1; board[3][4]=1; board[4][3]=1; turn=1; history=[]; moveHistory=[]; render(); }
function render(){ boardEl.innerHTML=''; const moves = legalMoves(board, turn); hintCells = Array.from(moves.keys()).map(k=>parseInt(k)); for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){ const idx=r*SIZE+c; const cell=document.createElement('div'); cell.className='cell'; cell.setAttribute('role','button'); cell.setAttribute('tabindex','0'); if(board[r][c]===1){ const d=document.createElement('div'); d.className='disc black'; cell.appendChild(d); cell.classList.add('disabled'); } else if(board[r][c]===-1){ const d=document.createElement('div'); d.className='disc white'; cell.appendChild(d); cell.classList.add('disabled'); } else { if(hintToggle.on && moves.has(idx)){ const hint=document.createElement('div'); hint.className='hint-dot'; cell.appendChild(hint); } }
    if(moves.has(idx)) cell.dataset.legal='1'; cell.addEventListener('click', ()=>onCellClick(idx)); cell.addEventListener('keydown',(e)=>{ if(e.key==='Enter') onCellClick(idx); }); boardEl.appendChild(cell); }
  const [bC,wC]=countPieces(board); blackScoreEl.textContent=bC; whiteScoreEl.textContent=wC; turnIndicator.textContent = aiThinking? 'AI thinking...' : (turn===1? "Black's turn":"White's turn"); renderMoves(); if(!aiThinking && turn!==playerSide){ aiMove(); } }
function renderMoves(){ movesEl.innerHTML=''; moveHistory.slice().reverse().forEach((m)=>{ const d=document.createElement('div'); d.className='move'; d.textContent = `${m.side===1? 'B':'W'} @ ${String.fromCharCode(65+m.c)}${m.r+1}`; movesEl.appendChild(d); }); }
function onCellClick(idx){ if(aiThinking) return; const moves = legalMoves(board, turn); if(!moves.has(idx)) return; history.push(copyBoard(board)); moveHistory.push({r:Math.floor(idx/SIZE),c:idx%SIZE,side:turn}); board = applyMove(board, turn, idx, moves.get(idx)); turn = -turn; if(legalMoves(board,turn).size===0){ if(legalMoves(board,-turn).size>0) turn=-turn; } render(); checkGameOver(); }
function undo(){ if(history.length===0 || aiThinking) return; board = history.pop(); const last = moveHistory.pop(); turn = last.side; render(); }

// controls
newBtn.addEventListener('click', ()=>initGame()); undoBtn.addEventListener('click', ()=>undo()); hintBtn.addEventListener('click', ()=>{ hintToggle.on = !hintToggle.on; render(); });
document.addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='u') undo(); if(e.key.toLowerCase()==='r') initGame(); });

diffRange.addEventListener('input', ()=>{ const v=parseInt(diffRange.value,10); depthLabel.textContent = v; }); depthLabel.textContent = diffRange.value;

themeBtn.addEventListener('click', ()=>{ const body=document.body; body.setAttribute('data-theme', body.getAttribute('data-theme')==='dark'?'light':'dark'); });
exportBtn.addEventListener('click',(e)=>{ e.preventDefault(); const data={board,turn,moveHistory}; const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='othello-game.json'; a.click(); URL.revokeObjectURL(url); });

function checkGameOver(){ if(legalMoves(board,1).size===0 && legalMoves(board,-1).size===0){ const [bC,wC]=countPieces(board); const winner = bC>wC? 'Black wins' : (wC>bC? 'White wins' : 'Draw'); setTimeout(()=>alert(`Game over — ${winner} (${bC} : ${wC})`),100); } }

// AI orchestration
function aiMove(){ aiThinking=true; render(); setTimeout(()=>{
  const diff = parseInt(diffRange.value,10); const timeMap={1:200,2:600,3:1200,4:3000,5:8000}; const timeBudget = timeMap[diff]||1200;
  const side = turn; const moves = legalMoves(board,side); if(moves.size===0){ aiThinking=false; turn=-turn; render(); return; }
  const res = findBestMove(board, side, timeBudget);
  if(res && res.move!=null){ history.push(copyBoard(board)); moveHistory.push({r:Math.floor(res.move/SIZE),c:res.move%SIZE,side:turn}); board = applyMove(board, side, res.move, moves.get(res.move)); }
  turn = -turn; if(legalMoves(board,turn).size===0){ if(legalMoves(board,-turn).size>0) turn=-turn; }
  aiThinking=false; render(); }, 40); }

// init
function autoPlayPreferredSide(){ const radios=document.getElementsByName('side'); for(const r of radios) r.addEventListener('change', ()=>{ playerSide = (r.value==='black'?1:-1); initGame(); if(playerSide!==1){ turn=1; render(); } }); }
autoPlayPreferredSide(); initGame();

</script>
</body>
</html>

